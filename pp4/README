In the final project, you will implement a back end for your compiler that will
generate code to be executed on the SPIM simulator. Finally, you get to the tru
product of all your labor -- running Decaf programs!

Design Decisions:

The code generation back end was implemented in multiple passes of the abstract
syntax tree (AST). The first pass is used to set up the memory location for any
global variables which might be present in the Decaf program. A second pass is
then used to set up the labels which are to be used for functions and methods.
Although, these two passes could probably be combined into a single pass, they
were implemented at different times and execution speed is not of importance.
The third and final pass of the AST is then to recursively generate the
intermediate representation (IR) of the program. As the tree is walked, each
nodes Emit method is called (in turn calling's it's children's Emit methods)
generating the IR code for that specific node.

Array are implemented as generic memory allocations, with some extra space
prepended to allocation to store it's size. For example:

        int[] arr;
        arr = NewArray(2, int);

corresponds to the following in memory representation:

        +-----+    +---+--------+--------+
        | arr |--->| 2 | arr[0] | arr[1] |
        +-----+    +---+--------+--------+

Objects are implemented as generic memory allocations, with some extra space
prepended to the allocation to store it's vtable. Derived member variables
contiguously follow inherited member variable in memory. Similarly, derived
method pointers contiguously follow inherited methods in a class's vtable. For
example:

        class B            { int x; M1() {} }
        class D1 extends B { int y; M1() {} }
        class D2 extends B { int y; M2() {} }

        B  b1;
        D1 d1;
        D2 d2;
        B  b2;

        B  b1 = new  B;
        D1 d1 = new D1;
        D2 d2 = new D2;
        B  b2 = new D2;

corresponds to the following in memory representation:

        +----+    +---------+------+
        | b1 |--->| b1.vtbl | b1.x |
        +----+    +---------+------+
                      |    +--------+
                      +--->| B.M1() |
                           +--------+

        +----+    +---------+------+------+
        | d1 |--->| d1.vtbl | d1.x | d1.y |
        +----+    +---------+------+------+
                      |     +---------+---------+
                      +---->| D1.M1() | D1.M1() |
                            +---------+---------+

        +----+    +---------+------+------+
        | d2 |--->| d2.vtbl | d2.x | d2.y |
        +----+    +---------+------+------+
                      |     +--------+---------+
                      +---->| B.M1() | D1.M1() |
                      |     +--------+---------+
        +----+    +---------+------+------+
        | b2 |--->| b2.vtbl | b2.x | b2.y |
        +----+    +---------+------+------+

Although this is not a very memory efficient way to implement polymorphism and
dynamic dispatch (the vtable for D1 instances are redundant), the
implementation was very straight forward.

Building:

To build the parser, the following are known dependences: make, flex, bison,
and gcc. Once those dependencies are properly installed, simply type 'make'
from within the top level directory. This should output the 'dcc' executable.
